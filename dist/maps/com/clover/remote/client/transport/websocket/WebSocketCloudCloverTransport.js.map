{"version":3,"sources":["com/clover/remote/client/transport/websocket/WebSocketCloudCloverTransport.ts"],"names":[],"mappings":"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","file":"../../../../../../../com/clover/remote/client/transport/websocket/WebSocketCloudCloverTransport.js","sourcesContent":["import http = require('http');\n\nimport {HttpSupport} from '../../../../util/HttpSupport';\nimport {Endpoints} from '../../../../util/Endpoints';\nimport {DeviceContactInfo} from '../../../../util/DeviceContactInfo';\n\nimport {WebSocketState} from '../../../../websocket/WebSocketState';\nimport {CloverWebSocketClient} from './CloverWebSocketClient';\n\nimport {WebSocketCloverTransport} from \"./WebSocketCloverTransport\";\n\n/**\n * WebSocket Cloud Clover Transport.  This handles the need to notify the device before a connection attempt is made.\n *\n */\nexport class WebSocketCloudCloverTransport extends WebSocketCloverTransport {\n\n    /**\n     * HTTP Header key that helps identify the connected client.  Typically set to the\n     * 'friendlyId'.\n     *\n     * @type {string}\n     */\n    static X_CLOVER_CONNECTED_ID: string = \"X-CLOVER-CONNECTED-ID\";\n\n    private httpSupport: HttpSupport;\n    private cloverServer: string;\n    private merchantId: string;\n    private accessToken: string;\n    private deviceId: string;\n    private friendlyId: string;\n    private forceConnect: boolean;\n\n    /**\n     * @param {number} heartbeatInterval - duration to wait for a PING before disconnecting\n     * @param {number} reconnectDelay - duration to wait until a reconnect is attempted\n     * @param retriesUntilDisconnect - unused\n     * @param {Object} webSocketImplClass - the function that will return an instance of the\n     *  CloverWebSocketInterface that will be used when connecting.  For Browser implementations, this can be\n     * @param {string} cloverServer the base url for the clover server used in the cloud connection.\n     *    EX:  https://www.clover.com, http://localhost:9000\n     * @param {string} merchantId - the merchant the device belongs to.\n     * @param {string} accessToken - the OAuth access token that will be used when contacting the clover server\n     * @param {string} deviceId - the id (not uuid) of the device to connect to\n     * @param {string} friendlyId - an identifier for the specific terminal connected to this device.  This id is used\n     *  in debugging and may be sent to other clients if they attempt to connect to the same device.  It will also be\n     *  sent to other clients that are currently connected if this device does a forceConnect.\n     * @param {boolean} forceConnect - if true, overtake any existing connection.\n     * @param {HttpSupport} httpSupport - the helper object used when making http requests.\n     */\n    public constructor(heartbeatInterval: number,\n                       reconnectDelay: number,\n                       retriesUntilDisconnect: number,\n                       webSocketImplClass: any,\n                       cloverServer: string,\n                       merchantId: string,\n                       accessToken: string,\n                       deviceId: string,\n                       friendlyId: string,\n                       forceConnect: boolean,\n                       httpSupport: HttpSupport) {\n        super(heartbeatInterval, reconnectDelay, retriesUntilDisconnect, webSocketImplClass);\n        this.cloverServer = cloverServer;\n        this.merchantId = merchantId;\n        this.accessToken = accessToken;\n        this.deviceId = deviceId;\n        this.httpSupport = httpSupport;\n        this.friendlyId = friendlyId;\n        this.forceConnect = forceConnect;\n\n        this.initialize();\n    }\n\n    /**\n     * The cloud needs to call an endpoint on the server to notify the device that it wants\n     * to talk.  This requires a valid OAuth access token, and we also need to know which Clover\n     * server to contact.\n     *\n     * To make the call, we also need to have an object that we can use that does not tie us to\n     * a particular environment.  This is the httpSupport.\n     *\n     * If an attempt is being made to reconnect, when this fails, it will set the 'reconnecting' flag to\n     * false to allow another reconnect attempt to be started by a separate 'thread'.\n     */\n    protected initialize(): void {\n        // Do the notification call.  This needs to happen every time we attempt to connect.\n        // It COULD mean that the device gets a notification when the Cloud Pay Display is\n        // already running, but this is not harmful.\n        let alertEndpoint: string = Endpoints.getAlertDeviceEndpoint(this.cloverServer, this.merchantId, this.accessToken);\n        let deviceContactInfo: DeviceContactInfo = new DeviceContactInfo(this.deviceId.replace(/-/g, \"\"), true);\n        this.httpSupport.postData(alertEndpoint,\n            (data) => this.deviceNotificationSent(data),\n            (error) => {\n                this.connectionError(this.cloverWebSocketClient, `Error sending alert to device. Details: ${error.message}`);\n                // This may end a reconnect attempt\n                this.setReconnecting(false);\n            },\n            deviceContactInfo);\n    }\n\n    /**\n     * This handles the response from the server of the request to send a notification to the device. If the\n     * notification was successful, then an OPTIONS call is made using the information provided.\n     *\n     * @param notificationResponse - has a boolean property for 'sent', that indicates if the notification\n     *  was sent to the device.  If it was, then the properties 'host' and 'token' are used to derive the\n     *  websocket endpoint uri.\n     */\n    private deviceNotificationSent(notificationResponse: any): void {\n        // Note \"!data.hasOwnProperty('sent')\" is included to allow for\n        // backwards compatibility.  If the property is NOT included, then\n        // we will assume an earlier version of the protocol on the server,\n        // and assume that the notification WAS SENT.\n        if (!notificationResponse.hasOwnProperty('sent') || notificationResponse.sent) {\n            let deviceWebSocketEndpoint: string = Endpoints.getDeviceWebSocketEndpoint(\n                notificationResponse.host, notificationResponse.token, this.friendlyId, this.forceConnect);\n            this.doOptionsCallToAvoid401Error(deviceWebSocketEndpoint);\n        } else {\n            this.connectionError(this.cloverWebSocketClient, \"Could not send alert to device.\");\n            // This may end a reconnect attempt\n            this.setReconnecting(false);\n        }\n    }\n\n    /**\n     * Do an OPTIONS call to the web socket endpoint (using http).  This helps with a problem where a 401\n     * response came back from the websocket endpoint.\n     *\n     * @param deviceWebSocketEndpoint\n     */\n    private doOptionsCallToAvoid401Error(deviceWebSocketEndpoint: string): void {\n        // A way to deal with the 401 error that\n        // occurs when a websocket connection is made to the\n        // server (sometimes).  Do a preliminary OPTIONS\n        // request.  Although this happens regardless of if the error\n        // happens, it is tremendously faster.\n        var deviceWebSocketEndpointCopy = deviceWebSocketEndpoint;\n\n        var httpUrl = null;\n        if (deviceWebSocketEndpointCopy.indexOf(\"wss\") > -1) {\n            httpUrl = deviceWebSocketEndpointCopy.replace(\"wss\", \"https\");\n        } else {\n            httpUrl = deviceWebSocketEndpointCopy.replace(\"ws\", \"http\");\n        }\n        this.httpSupport.options(httpUrl,\n            (data, xmlHttpReqImpl) => this.afterOptionsCall(deviceWebSocketEndpoint, xmlHttpReqImpl),\n            (data, xmlHttpReqImpl) => this.afterOptionsCall(deviceWebSocketEndpoint, xmlHttpReqImpl));\n    }\n\n    /**\n     * Handles the response to the OPTIONS call.  This helps with a 401 response, and is used to help identify\n     * any existing connection to the device.\n     *\n     * If the endpoint is available, then the transport is connected to the websocket.\n     *\n     * @param deviceWebSocketEndpoint\n     */\n    private afterOptionsCall(deviceWebSocketEndpoint: string, xmlHttpReqImpl: any): void {\n        // See com.clover.support.handler.remote_pay.RemotePayConnectionControlHandler#X_CLOVER_CONNECTED_ID\n        // This checks for an existing connection, which includes the id of the terminal that is connected.\n        let connectedId = \"\";\n        if (xmlHttpReqImpl && typeof xmlHttpReqImpl[\"getResponseHeader\"] === \"function\") {\n            connectedId = xmlHttpReqImpl.getResponseHeader(WebSocketCloudCloverTransport.X_CLOVER_CONNECTED_ID)\n        }\n        if (connectedId && !this.forceConnect) {\n            if (this.friendlyId == connectedId) {\n                // Do anything here?  This is already connected.\n                this.logger.debug(\"Trying to connect, but already connected to friendlyId '\" + this.friendlyId + \"'\");\n                if (this.cloverWebSocketClient) {\n                    this.cloverWebSocketClient.close();\n                }\n            } else {\n                this.connectionError(this.cloverWebSocketClient, \"Device is already connected to '\" + connectedId + \"'\");\n                // This may end a reconnect attempt\n                this.setReconnecting(false);\n                return; // done connecting\n            }\n            // If the device socket is already connected and good, just return.\n            if (this.cloverWebSocketClient && this.cloverWebSocketClient.getWebSocketState() == WebSocketState.OPEN) {\n                // This may end a reconnect attempt\n                this.setReconnecting(false);\n                return; // done connecting\n            }\n        }\n        super.initializeWithUri(deviceWebSocketEndpoint);\n    }\n\n    /**\n     *\n     * @override\n     * @param ws\n     */\n    public onOpen(ws: CloverWebSocketClient): void {\n        if (this.cloverWebSocketClient == ws) {\n            super.onOpen(ws);\n            this.notifyDeviceReady();\n        }\n    }\n}\n"]}